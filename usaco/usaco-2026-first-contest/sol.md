## Problem 1. Chip Exchange

题意：现有 a 个 A 类硬币，b 个 B 类硬币，每 cB 个 B 类硬币可以换取 cA 个 A 类硬币，问至少额外获得多少个随机类型的硬币时，我们必定可以持有 fA 个 A 类硬币 (<= 10^9)。

题解：假设至少需要额外获得 x 个硬币，由于 x 个硬币类型随机，我们要考虑最坏情况。

如果 cB <= cA，那么最差情况是你多出了 b - 1 个 B 类硬币，它们无法兑换 A 硬币。

如果 cB >= cA，那么随着 x 中 B 类硬币增加，我们能获得的 A 类硬币呈折线式减少，因此我们可以尝试 x 中全是 B 类硬币的情况，以及刚好多出了 b - 1 个 B 类硬币的情况，在二者中取一个最差情况。

对这几种最差情况，都求取一个需要的总硬币数量，输出其中最大值即可。

## Problem 2. COW Splits

题意：给定 N，再给出一个长度为 3N 的字符串 s，其中每三位组合是 "COW", "OWC", "WCO" 中的一个。每次你可以在 s 中选取一个子序列 X（偶数长度）删除，前提是 X 的前一半和后一半是同一字符串。问 s 是否能被消除为空串。如果能，要求出最小消除次数并给出消除方案。

题解：每次消除的是偶数个字符，所以 N 为奇数一定无解。若 N 为偶数，则每个字符的出现次数都是偶数次，我们必然可以依次消除所有的 C, O, W，所以在 3 步以内一定可以消除 s。

如果 s 前一半后一半相同，则只需要消 1 步。否则，我们可以把 s 分割为左右各一半，每次取 3 个字符为一组。假如左边是 "COW"，右边是 "WCO"，我们发现它们都有 "CO" 这个子串，因此我们把它们的 "CO" 划分为第一次消除，把 "W" 划分为第二次消除。后面每 3 个字符依次类推，即可构造出第一次消除的前后一半相同，第二次消除的前后一半也相同的消除方法。因此最多只要消除 2 次。

## Problem 3. Photoshoot

题意：有一个 $N * N$ (<= 600) 的网格，每个网格都有一头美丽值为 0 的牛。每次可以选择一个大小为 $K * K$ (k <= 25) 的网格拍照，照片的美丽值为拍到的所有奶牛的美丽值总和。有 Q (<= 3 * 10^4) 次更新，每次将一头奶牛的魅力值增加一个数。每次更新后，求出能拍到的美丽值最高是多少。

题解：我们可以直接用一个二维数组维护以 i, j 为左上角，大小为 $K * K$ 的网格中所有奶牛的美丽值总和。当一个点更新时，最多只有 $K * K$ 的网格会更新，我们同时用一个变量维护当前最大值。总复杂度为 $QK^2$，由于数据范围很小，刚好可以通过此题。
